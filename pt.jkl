#INCLUDE "vec.hjk"

STRUCT Piece
    Start : ULONG, // HSB is 0 for original, 1 for add
    Length : ULONG,
END

VecOf (
    Piece,
    VecPiece,
    VecPieceWithCapacity,
    VecPieceNew,
    VecPieceFree,
    VecPieceGrow,
    VecPieceReserveOne,
    VecPieceReserveAt,
)

STRUCT Pt
    Original : ^UBYTE,
    Add : VecUbyte,
    Pieces : VecPiece,
END

FN PtInit (
    IN original : ^UBYTE,
    IN length : UWORD,
    IN table : ^Pt,
)
    table^.Original = original
    VecUbyteNew(&table^.Add)
    VecPieceWithCapacity(1, &table^.Pieces)
    table^.Pieces.Length = 1
    table^.Pieces.Elems^.Start = 0
    table^.Pieces.Elems^.Length = length
END

FN PtFree (
    IN table : ^Pt,
)
    IF table^.Original THEN
        // FreeMemory(table^.Original)
    END
    VecUbyteFree(&table^.Add)
    VecPieceFree(&table^.Pieces)
END

// Given a byte index, returns the index of the piece containing that byte and the byte offset within that piece
FN PtSeek (
    IN self : ^Pt,
    IN seek_to : UWORD,
    OUT offset : UWORD,
) : WORD
    i := 0
    seek_at := 0
    WHILE i < self^.Pieces.Length DO
        len := self^.Pieces.Elems[i].Length
        IF seek_at + len > seek_to THEN
            offset = seek_to - seek_at
            RETURN i
        END
        seek_at += len
        i += 1
    END
    Assert(0, "out of bounds", seek_to, i)
END

FN PtAt (
    IN self : ^Pt,
    IN piece_index : UWORD,
    IN byte_offset : UWORD,
) : UBYTE
    piece := &self^.Pieces.Elems[piece_index]
    start := piece^.Start
    buffer : ^UBYTE
    IF start & 0x80000000 THEN
        buffer = self^.Add.Elems + (start - 0x80000000)
    ELSE
        buffer = self^.Original + start
    END
    RETURN buffer[byte_offset]
END

FN PtInsert (
    IN self : ^Pt,
    IN position : UWORD,
    IN char : UBYTE,
)
    offset : UWORD
    piece := PtSeek(self, position, OUT offset)
    Assert(offset == 0, "todo: insert inside piece", CAST piece TO UWORD, position)
    Assert(piece >= 0, "todo: insert at end of file", CAST piece TO UWORD, position)
    new_piece := VecPieceReserveAt(&self^.Pieces, CAST piece TO UWORD, 1)
    new_piece^.Start = self^.Add.Length | 0x80000000
    new_piece^.Length = 1
    VecUbyteReserveOne(&self^.Add)^ = char
END

STRUCT PtIterator
    Table : ^Pt,
    PieceIndex : WORD,
    ByteOffset : UWORD,
END

FN PtIteratorNew (
    IN table : ^Pt,
    IN seek_to : UWORD,
    IN iter : ^PtIterator,
)
    byte_offset : UWORD
    piece_index := PtSeek(table, seek_to, OUT byte_offset)
    iter^.Table = table
    iter^.PieceIndex = piece_index
    iter^.ByteOffset = byte_offset
END

FN PtIteratorSeekPosition(
    IN self : ^PtIterator,
    IN x : UBYTE,
    IN y : UBYTE,
    IN width : UBYTE,
    OUT offset : UWORD,
) : UWORD
    IF self^.PieceIndex == -1 THEN
        RETURN -1
    END
    
    self^.Table^.Pieces.Elems[self^.PieceIndex]
END
