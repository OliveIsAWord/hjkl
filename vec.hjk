#INCLUDE "os.hjk"
#INCLUDE "rom.hjk"

EXTERN FN Assert (
    IN condition : UBYTE,
    IN label : ^UBYTE,
    IN arg1 : UWORD,
    IN arg2 : UWORD,
)

STRUCT AllocationHeader
    Size : UWORD,
    _Prev : ^VOID,
    _Next : ^VOID,
END

#MACRO VecOf (
    T,
    VecT,
    VecTWithCapacity,
    VecTNew,
    VecTFree,
    VecTGrow,
    VecTReserveOne,
    VecTReserveAt,
) [

STRUCT VecT
    Capacity : UWORD, // allocation size in elements
    Length : UWORD, // number of elements in the list
    Elems : ^T, // pointer to array of elements
END

FN VecTWithCapacity (
    IN cap : UWORD,
    IN list : ^VecT
)
    IF cap == 0 THEN
        list^.Capacity = 0
        list^.Length = 0
        list^.Elems = NULLPTR
        LEAVE
    END
    bytes := cap * SIZEOF T
    ptr := AllocateMemory(bytes)
    list^.Elems = ptr
    list^.Length = 0
    IF NOT ptr THEN
        Assert(0, "out of memory", 0, 0)
    ELSE
        header : ^AllocationHeader = ptr - SIZEOF AllocationHeader
        // actual_capacity := header^.Size / SIZEOF T - SIZEOF AllocationHeader
        // Assert(cap == actual_capacity, "requested vs. actual capacity", cap, actual_capacity)
        list^.Capacity = cap
    END
    LEAVE
END

FN VecTNew (
    IN list : ^VecT,
)
    VecTWithCapacity(0, list)
END

FN VecTFree (
    IN list : ^VecT,
)
    IF list^.Elems THEN
        FreeMemory(list^.Elems)
    END
END

FN VecTGrow (
    IN list : ^VecT,
    IN necessary_capacity : UWORD,
)
    IF list^.Capacity >= necessary_capacity THEN
        LEAVE
    END
    new_list : VecT
    new_capacity := list^.Capacity / 2 * 3 + 8
    IF new_capacity < necessary_capacity THEN
        new_capacity = necessary_capacity
    END
    VecTWithCapacity(new_capacity, &new_list)
    IF list^.Length THEN
        CopyMemoryBytes(list^.Elems, new_list.Elems, list^.Length * SIZEOF T)
    END
    VecTFree(list)
    list^.Capacity = new_list.Capacity
    list^.Elems = new_list.Elems
END

FN VecTReserveOne (
    IN list : ^VecT,
) : ^T
    IF list^.Length >= list^.Capacity THEN
        VecTGrow(list, list^.Length + 1)
    END
    ptr := list^.Elems + list^.Length * SIZEOF T
    list^.Length += 1
    RETURN ptr
END

FN VecTReserveAt (
    IN self : ^VecT,
    IN index : UWORD, // the position to insert new elements
    IN additional : UWORD, // how many elements to insert
) : ^T
    new_length := self^.Length + additional
    IF new_length > self^.Capacity THEN
        VecTGrow(self, new_length)
    END
    i := self^.Length
    WHILE i >= index + 1 DO
        i -= 1
        CopyMemoryBytes(&self^.Elems[i], &self^.Elems[i + additional], SIZEOF T)
    END
    self^.Length = new_length
    RETURN &self^.Elems[index]
END
]

VecOf (
    UBYTE,
    VecUbyte,
    VecUbyteWithCapacity,
    VecUbyteNew,
    VecUbyteFree,
    VecUbyteGrow,
    VecUbyteReserveOne,
    VecUbyteReserveAt,
)
