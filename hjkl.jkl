#ASM [
pop a0 // streamPtr
pop a1 // arg0
pop a2 // arg1
pop a3 // arg2
// arg3 is now on the top of stack
call Main
]

// Hey, this comment is getting a little long, don't you think?

#DEFINE BLD_BITS 32
#DEFINE ARCHITECTURE "fox32"
#INCLUDE "rtl.hjk"
#INCLUDE "rom.hjk"
#INCLUDE "os.hjk"
#INCLUDE "pt.jkl"

EXTERN menu_bar : Menu

#ASM [
menu_bar:
    .db 1
    .dp menu_file_items
    .dp menu_file_name
menu_file_name:
    .db 4 .ds "File" .db 0
menu_file_items:
    .db 1
    .db 6
    .db 4 .ds "Save" .db 0
]

STRUCT FileLocation
    Disk : UBYTE,
    Name : ^UBYTE,
END

stream : ^File = NULLPTR // stdin and stdout
file_loc : FileLocation // the disk id and name of the opened file
window : Window // our gui window
window_title := "Hjkl - 0:12345678.123" // text displayed at the title bar
table : Pt // text data
view_byte_offset : UWORD = 0 // start of text view
cursor : UWORD = 0 // cursor position within file in bytes
// cursor_desired_offset : UWORD = 0 // how many columns further the cursor should "stick" to
width : UBYTE = 32 // number of columns in the text buffer
height : UBYTE = 20 // number of rows in the text buffer
redraw : UBYTE = TRUE // redraw the text buffer?

is_ctrl : UBYTE = FALSE // is the user holding the Ctrl key?

// Bitbee
// palette_fg : ULONG = 0xFF302B29
// palette_bg : ULONG = 0xFF4AABCF
// Paper palette
color_fg : ULONG = 0xFF3E3E3E
color_bg : ULONG = 0xFFC1E7F6
color_gutter : ULONG = 0xFFF0F8FF
// color_ultradark : ULONG = 0xFF242018

#DEFINE BOTTOM_BAR 0

small_digits : UINT[16] = {
    075557,
    026227,
    061247,
    061616,
    055711,
    074716,
    034757,
    071122,
    075757,
    075711,
    025755,
    065656,
    034443,
    065556,
    074647,
    074644,
}

FN Exit ()
    IF window.FrameBuffer THEN
        DestroyWindow(&window)
    END
    PtFree(&table)
    EndCurrentTask()
END

FN (RtlPrintCallbackF) RtljPrintCallback (
    IN byte : UBYTE,
    IN context : ^VOID,
)
    buffer : UBYTE[1]
    buffer[0] = byte
    Write(stream, &buffer[0], 1)
END

FN Assert (
    IN condition : UBYTE,
    IN label : ^UBYTE,
    IN arg1 : UWORD,
    IN arg2 : UWORD,
)
    IF NOT condition THEN
        RtlPrint("Assertion error: %s\nArg1: %d\nArg2: %d\n", label, arg1, arg2)
        Exit()
    END
END

FN ParseFilePath (
    IN fp : ^UBYTE,
    IN loc : ^FileLocation,
)
    IF fp[0] >= '0' AND fp[0] <= '9' AND fp[1] == ':' THEN
        loc^.Disk = fp[0] - '0'
        fp += 2
    END
    loc^.Name = fp
END

FN SaveFile ()
    file : File
    sector := Create(file_loc.Name, file_loc.Disk, &file, PtLength(&table))
    Assert(sector, "no room sory", file_loc.Disk, PtLength(&table))
    i := 0
    WHILE i < table.Pieces.Length DO
        piece := &table.Pieces.Elems[i]
        Write(&file, &table.Data.Elems[piece^.Start], piece^.Length)
        i += 1
    END
END

FN HandleMouseClick (
    IN x : UINT,
    IN y : UINT,
)
    IF y < 16 THEN // User clicked the title bar
        IF x < 8 THEN Exit() END // User clicked the close window button
        // Otherwise, drag the window
        StartDraggingWindow(&window) // NOTE: This blocks *all* tasks, including ours, until the user releases the mouse click
        LEAVE
    END
END

FN HandleCtrlKeyDown (
    IN scancode : UBYTE,
)
    IF scancode == 0x1F THEN
        SaveFile()
    ELSEIF scancode == 0x21 THEN
        IF cursor < PtLength(&table) THEN
            cursor += 1
        END
    ELSEIF scancode == 0x30 THEN
        IF cursor THEN
            cursor -= 1
        END
    END
END

FN HandleKeyDown (
    IN scancode : UBYTE,
)
    redraw = TRUE
    IF scancode == KEY_BACKSPACE THEN
        PtDelete(&table, cursor)
        IF cursor THEN
            cursor -= 1
        END
    ELSEIF scancode == KEY_CTRL THEN
        is_ctrl = TRUE
        redraw = FALSE
    ELSEIF scancode == KEY_LSHIFT OR scancode == KEY_RSHIFT THEN
        ShiftPressed()
        redraw = FALSE
    ELSEIF scancode == KEY_CAPS THEN
        CapsPressed()
        redraw = FALSE
    ELSEIF scancode == KEY_UP THEN
        // cursor_y -= 1
    ELSEIF scancode == KEY_DOWN THEN
        // cursor_y += 1
    ELSEIF scancode == KEY_LEFT THEN
        IF cursor THEN
            cursor -= 1
        END
    ELSEIF scancode == KEY_RIGHT THEN
        IF cursor < PtLength(&table) THEN
            cursor += 1
        END
    ELSEIF is_ctrl THEN
        HandleCtrlKeyDown(scancode)
    ELSEIF
        // TODO: Support keypad?
        0x02 <= scancode AND scancode <= 0x0D
     OR 0x10 <= scancode AND scancode <= 0x1C // notably, we include the Enter key in this range
     OR 0x1E <= scancode AND scancode <= 0x29
     OR 0x2B <= scancode AND scancode <= 0x35
     OR scancode == 0x39
    THEN
        c := ScancodeToAscii(scancode) // this is affected by ShiftPressed(), etc.
        PtInsert(&table, cursor, c)
        cursor += 1
    ELSE
        redraw = FALSE
    END
END

FN HandleKeyUp (
    IN scancode : UBYTE,
)
    IF scancode == KEY_LSHIFT OR scancode == KEY_RSHIFT THEN
        ShiftReleased()
    ELSEIF scancode == KEY_CTRL THEN
        is_ctrl = FALSE
    END
END

FN HandleMenuClick (
    IN menu : UWORD,
    IN item : UWORD,
)
    Assert(menu == 0 AND item == 0, "invalid menu choice", menu, item)
    SaveFile()
END

FN DrawPixel (
    IN x : UINT,
    IN y : UINT,
    IN agh : ULONG,
)
    xx := &window.FrameBuffer[window.Width * y + x]
    xx^ = agh
END

FN DrawReplacementTile (
    IN c : UBYTE,
    IN x : UINT,
    IN y : UINT,
    IN fg_color : ULONG,
    IN bg_color : ULONG,
)
    i := 1
    WHILE i < 8 DO
        DrawPixel(x + i, y, bg_color)
        DrawPixel(x + i, y + 1, fg_color)
        DrawPixel(x + i, y + 2, bg_color)
        DrawPixel(x + i, y + 8, bg_color)
        DrawPixel(x + i, y + 14, bg_color)
        DrawPixel(x + i, y + 15, fg_color)
        i += 1
    END
    i = 0
    WHILE i < 16 DO
        DrawPixel(x, y + i, bg_color)
        i += 1
    END
    i = 2
    WHILE i < 15 DO
        DrawPixel(x + 1, y + i, fg_color)
        DrawPixel(x + 2, y + i, bg_color)
        DrawPixel(x + 6, y + i, bg_color)
        DrawPixel(x + 7, y + i, fg_color)
        i += 1
    END
    i = 0
    WHILE i <= 1 DO
        half := (c >> (i * 4)) & 0xF
        bit_image := small_digits[half]
        dy := 0
        WHILE dy < 5 DO
            dx := 0
            WHILE dx < 3 DO
                bit_color := bg_color
                IF (bit_image >> (14 - dy * 3 - dx)) & 1 THEN
                    bit_color = fg_color
                END
                DrawPixel(x + 3 + dx, y + 9 + dy - i * 6, bit_color)
                dx += 1
            END
            dy += 1
        END
        i += 1
    END
END

FN DrawTextBuffer ()
    gutter_y := 0
    WHILE gutter_y < height DO
        DrawFontTileToOverlay(' ', 0, gutter_y * 16 + 16, 0, color_gutter, window.Overlay)
        DrawFontTileToOverlay(' ', (width + 1) * 8, gutter_y * 16 + 16, 0, color_gutter, window.Overlay)
        gutter_y += 1
    END
    inner_offset : UWORD
    i := PtSeek(&table, view_byte_offset, OUT inner_offset)
    x := 0
    y := 0
    bytes_until_cursor := cursor - view_byte_offset
    WHILE TRUE DO
        piece := &table.Pieces.Elems[i]
        start := piece^.Start
        c := table.Data.Elems[start + inner_offset]
        color1 := color_fg
        color2 := color_bg
        IF bytes_until_cursor == 0 THEN
            color1 = color_bg
            color2 = color_fg
        END
        display_x := (x + 1) * 8
        display_y := (y + 1) * 16
        IF c == 0x0a THEN // newline
            DrawFontTileToOverlay(' ', display_x, display_y, color1, color2, window.Overlay)
            x += 1
            WHILE x < width DO
                display_x = (x + 1) * 8
                DrawFontTileToOverlay(' ', display_x, display_y, color_fg, 0xFFFF00FF, window.Overlay)
                x += 1
            END
        ELSE
            IF c < 0x20 OR c > 0x7E THEN // unprintable character
                DrawReplacementTile(c, display_x, display_y, color1, color2)
            ELSE // printable character
                DrawFontTileToOverlay(c, display_x, display_y, color1, color2, window.Overlay)
            END
            x += 1
        END
        IF x >= width THEN
            x = 0
            y += 1
            IF y >= height THEN
                BREAK
            END
        END
        bytes_until_cursor -= 1
        inner_offset += 1
        IF inner_offset >= piece^.Length THEN
            inner_offset = 0
            i += 1
            IF i >= table.Pieces.Length THEN
                BREAK
            END
        END
    END
    IF y < height AND bytes_until_cursor == 0 THEN
        display_x := (x + 1) * 8
        display_y := (y + 1) * 16
        DrawFontTileToOverlay(' ', display_x, display_y, 0, color_fg, window.Overlay)
        x += 1
        IF x >= width THEN
            x = 0
            y += 1
        END
    END
    WHILE y < height DO
        WHILE x < width DO
            display_x := (x + 1) * 8
            display_y := (y + 1) * 16
            DrawFontTileToOverlay(' ', display_x, display_y, color_fg, 0xFF00FF00, window.Overlay)
            x += 1
        END
        x = 0
        y += 1
    END
    IF BOTTOM_BAR THEN
        bar_x := 0
        WHILE bar_x < width + 2 DO
            DrawFontTileToOverlay(' ', bar_x * 8, y * 16 + 16, 0, color_gutter, window.Overlay)
            bar_x += 1
        END
    END
END

EXTERN FN Millis () : UWORD
#ASM [
Millis:
.global Millis
    in a3, 0x80000706
    ret
]

FN PreMain (
    IN stream_ : ^File,
)
    stream = stream_
    file_loc.Name = NULLPTR
    window.FrameBuffer = NULLPTR
    PtNull(&table)
END
    
FN Main (
    IN stream_ : ^File,
    IN arg0 : ^UBYTE,
    IN arg1 : ^UBYTE,
    IN arg2 : ^UBYTE,
    IN arg3 : ^UBYTE,
)
    PreMain(stream_)
    IF NOT arg0 OR arg1 | arg2 | arg3 THEN
        RtlPrint("Usage: hjkl <file>\n")
        Exit()
    END
    file_loc.Disk = GetCurrentDiskId()
    ParseFilePath(arg0, &file_loc)
    IF TRUE THEN
        file : File
        IF NOT Open(file_loc.Name, file_loc.Disk, &file) THEN
            RtlPrint("Could not find file %s\n", file_loc.Name)
            EndCurrentTask()
        END
        PtInit(&file, &table)
        RtlPrint("opened %d:%s of %d bytes\n", file_loc.Disk, file_loc.Name, GetSize(&file))
    END
    
    // create window title
    IF TRUE THEN
        window_title[7] = '0' + file_loc.Disk
        i := 0
        WHILE TRUE DO
            window_title[i + 9] = file_loc.Name[i]
            IF file_loc.Name[i] == 0 THEN BREAK END
            i += 1
        END
    END
    
    NewWindow(&window, window_title, (width + 2) * 8, height * 16, 160, 20, &menu_bar, 0)
    FillWindow(&window, color_bg)
    
    WHILE TRUE DO
        // Poll events until our queue is empty
        WHILE TRUE DO
            ev : Event
            GetNextWindowEvent(&window, &ev)
            IF ev.Type == EVENT_TYPE_EMPTY THEN
                BREAK
            ELSEIF ev.Type == EVENT_TYPE_MOUSE_CLICK THEN
                HandleMouseClick(ev.Body.Pos.X, ev.Body.Pos.Y)
            ELSEIF ev.Type == EVENT_TYPE_KEY_DOWN THEN
                HandleKeyDown(ev.Body.Scancode)
            ELSEIF ev.Type == EVENT_TYPE_KEY_UP THEN
                HandleKeyUp(ev.Body.Scancode)
            ELSEIF ev.Type == EVENT_TYPE_MENU_BAR_CLICK THEN
                MenuBarClickEvent(&menu_bar, ev.Body.Pos.X)
            ELSEIF ev.Type == EVENT_TYPE_MENU_UPDATE THEN
                MenuUpdateEvent(&menu_bar, ev.Body.MenuChoice.Menu, ev.Body.MenuChoice.Item)
            ELSEIF ev.Type == EVENT_TYPE_MENU_CLICK THEN
                HandleMenuClick(ev.Body.MenuChoice.Menu, ev.Body.MenuChoice.Item)
            ELSEIF ev.Type == EVENT_TYPE_MENU_ACK THEN
                CloseMenu(&menu_bar)
            END
        END
        // Redraw the text buffer
        IF redraw THEN
            redraw = FALSE
            DrawTextBuffer()
            // PtDebug(&table)
        END
        YieldTask()
    END
END
