#ASM [
pop a0 // streamPtr
pop a1 // arg0
pop a2 // arg1
pop a3 // arg2
// arg3 is now on the top of stack
call Main
]

// Hey, this comment is getting a little long, don't you think?

#INCLUDE "fox32rom.def.hjk"
#INCLUDE "fox32os.def.hjk"
// #INCLUDE "array_list.hjk"
#INCLUDE "piece_table.jkl"

STRUCT FileLocation
    Disk : UBYTE,
    Name : ^UBYTE,
END

stream : ^File
file_loc : FileLocation
window : Window
window_title := "Hjkl - 0:12345678.123"
table : PieceTable
view_byte_offset : UWORD = 0
cursor_x : UBYTE = 0
cursor_y : UBYTE = 0
width : UBYTE = 32
height : UBYTE = 20

// Bitbee
// palette_fg : ULONG = 0xFF302B29
// palette_bg : ULONG = 0xFF4AABCF
// Paper palette
palette_fg : ULONG = 0xFF3E3E3E
palette_bg : ULONG = 0xFFC1E7F6

small_digits : UINT[16] = {
    075557,
    026227,
    061247,
    061616,
    055711,
    074716,
    034757,
    071122,
    075757,
    075711,
    025755,
    065656,
    034443,
    065556,
    074647,
    074644,
}

FN Exit ()
    IF window.FrameBuffer THEN
        DestroyWindow(&window)
    END
    PieceTableFree(&table)
    EndCurrentTask()
END

FN Print (
    IN str : ^UBYTE,
)
    len := StringLength(str)
    Write(stream, str, len)
END

FN PrintUword (
    IN x : UWORD,
)
    digit := 1
    WHILE digit <= x DO
        old_digit := digit
        digit *= 10
        IF old_digit > digit THEN
            digit = old_digit
            BREAK
        END
    END
    IF digit > 1 THEN
        digit /= 10
    END
    WHILE digit DO
        d := x / digit
        c := "0123456789" + d
        Write(stream, c, 1)
        x -= d * digit
        digit /= 10
    END
END

FN PrintNewline ()
    Write(stream, "\n", 1)
END

FN Println (
    IN str : ^UBYTE,
)
    len := StringLength(str)
    Write(stream, str, len)
    PrintNewline()
END

FN Hex (
    IN n : UWORD,
)
    i : WORD = 28
    WHILE i >= 0 DO
        x := (n >> i) & 0xF
        c := "0123456789ABCDEF" + x
        Write(stream, c, 1)
        i -= 4
    END
END

FN Assert (
    IN condition : UBYTE,
    IN label : ^UBYTE,
    IN arg1 : UWORD,
    IN arg2 : UWORD,
)
    IF condition THEN LEAVE END
    Print("Assertion error: ")
    Println(label)
    Print("Arg1: ")
    PrintUword(arg1)
    PrintNewline()
    Print("Arg2: ")
    PrintUword(arg2)
    PrintNewline()
    Exit()
END

FN ParseFilePath (
    IN fp : ^UBYTE,
    IN loc : ^FileLocation,
)
    IF fp[0] >= '0' AND fp[0] <= '9' AND fp[1] == ':' THEN
        loc^.Disk = fp[0] - '0'
        fp += 2
    END
    loc^.Name = fp
END

FN HandleMouseClick (
    IN x : UINT,
    IN y : UINT,
)
    IF y < 16 THEN // User clicked the title bar
        IF x < 8 THEN Exit() END // User clicked the close window button
        // Otherwise, drag the window
        StartDraggingWindow(&window) // NOTE: This blocks *all* tasks, including ours, until the user releases the mouse click
        LEAVE
    END
END

FN HandleKeyDown (
    IN scancode : UBYTE,
)
    IF scancode == KEY_UP THEN
        cursor_y -= 1
    ELSEIF scancode == KEY_DOWN THEN
        cursor_y += 1
    ELSEIF scancode == KEY_LEFT THEN
        cursor_x -= 1
    ELSEIF scancode == KEY_RIGHT THEN
        cursor_x += 1
    END
END

FN HandleKeyUp (
    IN scancode : UBYTE,
)
END

FN DrawPixel (
    IN x : UINT,
    IN y : UINT,
    IN agh : ULONG,
)
    xx := &window.FrameBuffer[window.Width * y + x]
    xx^ = agh
END

FN DrawReplacementTile (
    IN c : UBYTE,
    IN x : UINT,
    IN y : UINT,
    IN fg_color : ULONG,
    IN bg_color : ULONG,
)
    i := 1
    WHILE i < 8 DO
        DrawPixel(x + i, y, bg_color)
        DrawPixel(x + i, y + 1, fg_color)
        DrawPixel(x + i, y + 2, bg_color)
        DrawPixel(x + i, y + 8, bg_color)
        DrawPixel(x + i, y + 14, bg_color)
        DrawPixel(x + i, y + 15, fg_color)
        i += 1
    END
    i = 0
    WHILE i < 16 DO
        DrawPixel(x, y + i, bg_color)
        i += 1
    END
    i = 2
    WHILE i < 15 DO
        DrawPixel(x + 1, y + i, fg_color)
        DrawPixel(x + 2, y + i, bg_color)
        DrawPixel(x + 6, y + i, bg_color)
        DrawPixel(x + 7, y + i, fg_color)
        i += 1
    END
    i = 0
    WHILE i <= 1 DO
        half := (c >> (i * 4)) & 0xF
        bit_image := small_digits[half]
        dy := 0
        WHILE dy < 5 DO
            dx := 0
            WHILE dx < 3 DO
                bit_color := bg_color
                IF (bit_image >> (14 - dy * 3 - dx)) & 1 THEN
                    bit_color = fg_color
                END
                DrawPixel(x + 3 + dx, y + 9 + dy - i * 6, bit_color)
                dx += 1
            END
            dy += 1
        END
        i += 1
    END
END

FN DrawTextBuffer ()
    inner_offset : UWORD
    i := PieceTableSeek(&table, view_byte_offset, OUT inner_offset)
    x := 0
    y := 0
    WHILE TRUE DO
        piece := &table.Pieces.Elems[i]
        start := piece^.Start
        buffer : ^UBYTE
        IF start & 0x80000000 THEN
            start -= 0x80000000
            buffer = table.Add.Elems
        ELSE
            buffer = table.Original
        END
        c := buffer[start + inner_offset]
        is_cursor := x == cursor_x AND y == cursor_y
        display_x := (x + 1) * 8
        display_y := (y + 1) * 16
        IF c == 0x0a THEN // newline
            IF is_cursor THEN
                DrawFontTileToOverlay(0x8a, display_x, display_y, palette_fg, 0, window.Overlay)
            END
            x = 0
            y += 1
            IF y >= height THEN
                BREAK
            END
        ELSE
            color1 := palette_fg
            color2 := palette_bg
            IF is_cursor THEN
                temp := color1
                color1 = color2
                color2 = temp
            END
            IF c < 0x20 OR c > 0x7E THEN // unprintable character
                DrawReplacementTile(c, display_x, display_y, color1, color2)
            ELSE // printable character
                DrawFontTileToOverlay(c, display_x, display_y, color1, color2, window.Overlay)
            END
            x += 1
            IF x >= width THEN
                x = 0
                y += 1
                IF y >= height THEN
                    BREAK
                END
            END
        END
        inner_offset += 1
        IF inner_offset >= piece^.Length THEN
            inner_offset = 0
            i += 1
            IF i >= table.Pieces.Length THEN
                BREAK
            END
        END
    END
END

EXTERN FN Millis () : UWORD
#ASM [
Millis:
.global Millis
    in a3, 0x80000706
    ret
]

FN PreMain (
    IN stream_ : ^File,
)
    stream = stream_
    file_loc.Name = NULLPTR
    window.FrameBuffer = NULLPTR
    PieceTableInit(NULLPTR, 0, &table)
END
    
FN Main (
    IN stream_ : ^File,
    IN arg0 : ^UBYTE,
    IN arg1 : ^UBYTE,
    IN arg2 : ^UBYTE,
    IN arg3 : ^UBYTE,
)
    PreMain(stream_)
    IF NOT arg0 OR arg1 | arg2 | arg3 THEN
        Println("Usage: hjkl <file>")
        Exit()
    END
    file_loc.Disk = GetCurrentDiskId()
    ParseFilePath(arg0, &file_loc)
    file : File
    IF NOT Open(file_loc.Name, file_loc.Disk, &file) THEN
        Print("Could not find file ")
        Println(file_loc.Name)
        EndCurrentTask()
    END
    size := GetSize(&file)
    Print("opened ")
    PrintUword(file_loc.Disk)
    Print(":")
    Print(file_loc.Name)
    Print(" of ")
    PrintUword(size)
    Println(" bytes")
    text_buffer : ^UBYTE = AllocateMemory(size)
    IF NOT text_buffer THEN
        Println("oops! oom")
        Exit()
    END
    Read(&file, text_buffer, size)
    FreeMemory(text_buffer)
    PieceTableFree(&table)
    PieceTableInit(text_buffer, size, &table)
    
    // create window title
    IF TRUE THEN
        window_title[7] = '0' + file_loc.Disk
        i := 0
        WHILE TRUE DO
            window_title[i + 9] = file_loc.Name[i]
            IF file_loc.Name[i] == 0 THEN BREAK END
            i += 1
        END
    END

    Print(window_title) Print(" ")
    PrintUword(width) Print("x")
    PrintUword(height) PrintNewline()
    
    NewWindow(&window, window_title, (width + 1) * 8, (height + 2) * 16, 160, 20, 0, 0)
    FillWindow(&window, palette_bg)
    
    WHILE TRUE DO
        DrawTextBuffer()
        YieldTask()
        ev : Event
        GetNextWindowEvent(&window, &ev)
        IF ev.Type == EVENT_TYPE_MOUSE_CLICK THEN
            HandleMouseClick(ev.Body.Pos.X, ev.Body.Pos.Y)
        ELSEIF ev.Type == EVENT_TYPE_KEY_DOWN THEN
            HandleKeyDown(ev.Body.Scancode)
        ELSEIF ev.Type == EVENT_TYPE_KEY_UP THEN
            HandleKeyUp(ev.Body.Scancode)
        END
    END
END
